---
title: "Инструкция к пакету RBOINC"
author: "Сергей Астафьев aka ProgGrey"
date: 27.01.2022
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RBOINC-RU}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Высокоуровневая архитектура
В этом разделе описывается общая архитектура RBOINC. Информация в этом разделе предназначена только для администраторов BOINC проектов и волонтёров, которые хотят установить RBOINC или участвовать в проектах, основанных на нём соотвественно. Если вы являетесь волонтёром, перейдите к подразделу [Компьютеры волонтёров](#volunteers_computers). Если вы не являетесь администратором своего проекта BOINC, [пропустите](#RBOINC.cl) этот раздел.

## Как работает RBOINC


## Виртуальная машина
Изначально предполагалось, что тот, кто захочет использовать пакет RBOINC должен самостоятельно собрать виртуальную машину. Теперь предполагается, что вы возьмёте готовую, заранее настроенную ВМ и просто доустановите необходимые пакеты и ПО. Далее описывается досборка готовой ВМ. Инструкцию по сборке ВМ с нуля ищите в подразделе [сборка виртуальной машины с нуля](#Build_vm_from_scratch).

### Досборка готовой виртуальной машины
Предварительно собранные виртуальные машины могут быть найдены по этой ссылке: https://disk.yandex.ru/d/e_aItFuMPfKF2A. Поддерживаются только архитекуры i686 и amd64. Обе ВМ собраны на основе Gentoo Linux.

Для каждой архитектуры я предоставляю 2 виртуальные машины:

* Суффикс "release" означает, что ВМ предназначена для загрузки на сервер BOINC. Она включает в себя базовый набор пакетов, необходимый для работы виртуальной машины на компьютерах волонтёров. В R установлены только базовые пакеты, пакет "doParallel" и его зависимости.

* Виртуалки без суффикса предназначены для технического обслуживани и последующей сборки релизной версии. Эти ВМ содержат всё то-же, что и версии с суффиксом "relese", плюс дополнительные пакеты и файлы необходимые для полноценной работы ОС.

Рекомендуемый способ досборки зависит от того, что вам нужно поменять в образах виртуальных машин:

* Если необходимо только установить дополнительные пакеты R, которые не требуют библиотек за исключением тех, что уже установлены в ВМ, то алгоритм следующий:

  1. Скачать "release" версию виртуальной машины.
  
  1. Загрузить её. После загрузки вам необходимо будет перехватить управление, прервав исполнение скрипта выполнения работы, успев нажать Ctrl+C (у вас на это 1 секунда).
  
  1. Переключиться на второй терминал с помощью Ctrl+Alt+F2.
  
  1. Войти с логином "root" и паролем "0000".
  
  1. Запустить R и установить необходимые пакеты.
  
  1. Завершить работу, выполнив "shutdown -hP now".
  
* Если необходимо установить дополнительное ПО, то алгоритм следуюший:

  1. Скачать версию ВМ без суффикса "release".
  
  1. Загрузить её. Переключиться на второй терминал с помощью Ctrl+Alt+F2.
  
  1. Войти с логином "root" и паролем "0000".
  
  1. Установить/обновить необходимое ПО и пакеты R.
  
  1. Выполнить скрипт "prepare_release.sh", находящийся в домашней директории root.
  
  1. Сделать снимок состояния машины. Выполнить скрипт "make_release.sh"
  
  1. Завершить работу, выполнив "shutdown -hP now".
  
  1. Скачать соотвествующей архитектуре Admin CD: https://www.gentoo.org/downloads/.
  
  1. Подключить пустой виртуальный жёсткий диск и Admin CD к виртуалке.
  
  1. Загрузиться с Admin CD.
  
  1. Разметить пустой диск: раздел UEFI 2 мб, раздел boot 32 Мб, остальное - rootfs.
  
  1. Файловые системы: boot - ext2, rootfs - btrfs с опциями "-M -s 4096 -n 4096 -O skinny-metadata,no-holes"
  
  1. Смонтировать: /dev/new3 -> /mnt/new с параметром "compress-force=zstd:15", /dev/new2 -> /boot, /dev/old3 -> /mnt/old, /dev/old2 /mnt/old/boot
  
  1. Скопировать данные из старой ФС в новую, например так: "rsync -avxHAXW /mnt/old/ /mnt/new/", "rsync -avxHAXW /mnt/old/boot/ /boot/"
  
  1. Восстановить загрузчик. Admin CD в отличие от Minimal installation CD содержит grub2, и поэтому восстановление выполняется в два этапа:
  
    1. Установка загрузчика: "grub-install --themes=none --compress=xz /dev/new"
    
    1. Запись правильных UUID в файл /boot/grub/grub.cfg 
    
  1. Проверьте, что ВМ загружается с нового диска. Сборка закончена.

### Сборка виртуальной машины с нуля {#Build_vm_from_scratch}
Сборка виртуальной машины с нуля занимает намного больше времени, чем обновление готовой. Однако такая ВМ может иметь преимущества: вы можете использовать любой дистрибутив Linux или даже любую другую ОС. Единственное требование - в выбранной вами операционной системе должен работать интерпритатор R. Перед сборкой вртуальной машины убедитесь, что лицензия ОС позволяет выполнять с ней подобные действия, в частности распространять неограниченному кругу лиц и модифицировать.

В целом сборку с нуля можно разделить на следующие этапы:

1. Уставновите операционную систему в виртуальную машину.

1. Установите гостевые дополнения VirtualBox.

1. Установите интерпритатор R.

1. Добавьте в автомонтирование при загрузке глобальную папку VirtualBox с именем shared.

1. Если ваша система Linux, то вы можете просто добавить файл boinc/boinc_app.sh в автозагрузку. Только убедитесь, что вы выполняете монтирование папки shared в место, которое ожидает скрипт и созданы все необходимые папки, которые ожидает скрипт. Если ваша система не linux, то перепишите этот скрипт так, что-бы сохранилась логика его работы.

1. В зависимости от вашей ОС вам могут потребоваться дополнительные действия. Смотрите HowToInstall.txt в папке back-end/VM.

## Серверная часть
Серверная часть состоит из компонентов, которые реализуют функции, или не предоставляемые BOINC, или более удобные для использования в этом пакете обёртки над интерфейсами BOINC. Серверная часть должна быть установлена на проект BOINC до создания заданий. Обратите внимание на то, что серверная часть включает в себя стороннии компоненты, которые могут лицензироваться на условиях лицензий, отличных от BSD3.

Установка компонентов заключается в копировании содержимого папки "/back-end/Server/project" в директорию вашего проекта BOINC и последующем редактировании конфигурационных файлов.

### Валидатор
В серверную часть входит валидатор, который выполняет простейшие проверки присланных заданий. Для его сборки скопируйте папку "validator" в папку с исходными файлами BOINC, перейдите в папку "validator" и выполните "make". Предполагается, что перед этим BOINC был сконфигурирован и собран(См. https://boinc.berkeley.edu/trac/wiki/ServerIntro).

Этот валидатор требует установки интерпритатора R на сервер. В будущем это требование может стать необязательным, а может и не стать. В качестве альтернативы можно использовать sample_trivial_validator из стандартной поставки BOINC.

### Папка apps
В этой директории находятся файлы приложений. Обратите внимание, что ВМ не хранится в репозитории и должна быть скачана и добавлена отдельно. Это сделано из-за того, что ВМ часто меняется и занимает много места.

Официально поддериваются только ОС семейства Linux и Windows, использующие ахитектуры amd64 и i686. Теоретически возможна поддержка MacOS, с теми-же архитектурами (см. https://boinc.berkeley.edu/trac/wiki/VboxApps) но я не нашёл компьютера с ней для проверки.

### Папка rboinc
Содержит файлы, которые изначально были созданы для ssh протокола и предоставляли функции, к которым не было прямого доступа из командной оболочки. Позже они были расширены и теперь предоставляют дополнительно функции для пакета, в первую очередь это генерация уникальных имён для файлов и пачек работ.

### Файл html/user/rboinc_upload_archive.php
Предоставляет низкоуровневый(но более высокоуровневый, чем оригинальный интерфейс BOINC) интерфейс для загрузки файлов на сервер BOINC по http/https протоколам. Дополнительно сообщает пакету имя для создания пачки работ.

### Папка templates
Шаблоны для входных и выходных файлов BOINC. Подробнее см. в https://boinc.berkeley.edu/trac/wiki/JobTemplates.

## Компьютеры волонтёров {#volunteers_computers}
Подготовка компьютера волонтёра к работе с проектом, основанным на RBOINC достаточно проста. Необходимо установить BOINC Manager, VirtualBox и VirtualBox Extension Pack, а также включить аппаратную виртуализацию в настройках BIOS/UEFI. После установки необходимого ПО рекомендуется выполнить перезагрузку. После этого проект можно добавлять в BOINC Manager. 

Также рекомендуется добавить в запуск по расписанию каждые несколько минут команду "boinccmd --project \<Project URL\> update". В данный момент у проекта есть некоторые проблемы связанные с тем, что в определённый момент число заданий на сервере может стать нулевым. В этом случае BOINC Client перестаёт запрашивать новые задания и заставить его это сделать можно или ручным обновлением проекта или перезагузкой компьютера. Я не нашёл решения этой проблемы в документации BOINC, если знаете, как её решить - пошлите мне письмо на почту или добавьте feature request в репозитории RBOINC. 

Если ваша операционная система Ubuntu и выполнении заданий завершается с ошибкой "Postponed: VM job unmanageable, restarting later", то добавьте в атозагрузку запуск "vboxwebsrv" от пользователя "boinc" и перезагрузите компьютер. Это может распространяться и на другие ОС семейства Linux.

## Пакет R

Пакет RBOINC.cl это клиентская часть RBOINC. Он должен быть установлен на компьютеры клиентов, которые хотят запускать свои задания с помощью RBOINC. Для клиентов установка выполняется максимально просто, достаточно выполнить:
``` {r eval=FALSE}
install.packages(c('R.utils', 'askpass', 'foreach', 'httr', 'ssh', 'xml2', 'stats', 'utils', 'doParallel', 'parallel'))
install.packages("RBOINC.cl", repos="http://R-Forge.R-project.org")
```
Обратите внимание, что в данный момент пакет находится на стадии бета теста и его не рекомендуется использовать в продакшене. В дальнейшем планируется отправка пакета в CRAN.

Администратор проекта RBOINC должен предоставить клиенту следующую информацию:

* Если используется http/https протокол:
  * URL сервера
  * Путь до страницы проекта (без сервера).
  * Адрес почты и пароль клиент указывает сам при регистрации в проекте RBOINC. Администратор только выдаёт права на создание работы(см. https://boinc.berkeley.edu/trac/wiki/MultiUser).
* Если используется ssh протокол:
  * Адрес сервера
  * Путь до папки проекта
  * Логин и пароль клиента или файл ключа.

Для использования рекомендуется http интерфейс. Подробности о нём вы можете найти в https://boinc.berkeley.edu/trac/wiki/MultiUser. Обратите внимание, что вопреки тому, что написано на вики BOINC, высокоуровневое управление(файлы BOINC "manage_project.php" и "submit.php") эти интерфейсом недоделано. Тем не менее, на низком уровне, этот интерфейс работает и RBOINC.cl использует его для создания заданий и разграничений прав доступа.

Если вы собираетесь использовать ssh интерфейс, то вы должны добавить соответствующего пользователя в группы администратора вашего проекта и www-data, и установить его umask в значение, позволяющее другим пользователям из этих групп читать его файлы. В будущем это требование может быть убрано.

# Использование пакета R {#RBOINC.cl}

## Начало работы
В данный момент пакет находится в статусе беты. Установить его можно следующим образом:
``` {r eval=FALSE}
install.packages(c('R.utils', 'askpass', 'foreach', 'httr', 'ssh', 'xml2', 'stats', 'utils', 'doParallel', 'parallel'))
install.packages("RBOINC.cl", repos="http://R-Forge.R-project.org")
```
Для работы проекта вам необходима учётная запись с правами на создание работы. Обратитесь к администратору вашего проекта RBOINC для получения данных для авторизации.

## Функция test_jobs
Я начинаю с функции тестирования, потому что её можно использовать без необходимости в учётной записи в проекте RBOINC.

### Параметры work_func и data
Подключим пакет и выполним простейший код, умножающий вектор из 9 элементов на 5:
```{r }
library(RBOINC.cl)

fun = function(val)
{
  return(val*5)
}

data = 1:9

res = test_jobs(fun, data)

for(val in res){
  print(val$result)
}
```

Функция создала 9 заданий, по числу элементов в data. Если параметр n не задан, то число заданий будет равно длине data.  data должен быть вектором или нумерованным списком. n должен быть меньше или равен длине data (но больше нуля). Если длина data не делится нацело на n, то у каких-то заданий окажется меньше работы. У work_func должен быть только 1 параметр, в который будет передан элемент data.

### Параметр n {#test_jobs_example_2}
Давайте создадим 2 задания вместо 9:
```{r }
library(RBOINC.cl)

fun = function(val)
{
  return(val*5)
}

data = 1:9

res = test_jobs(fun, data, 2)

for(val in res){
  print(val$result)
}
```

Функция обработки данных может быть рекурсивной. Давайте посчитаем факториал:
```{r }
library(RBOINC.cl)

fac = function(val)
{
  if(val == 0 || val == 1){
    return(val)
  } else {
    return(val*fac(val- 1))
  }
}

data = 1:9

res = test_jobs(fac, data, 2)

for(val in res){
  print(val$result)
}
```

### Пропуск параметра data, параметры global_vars и packages
Если вам не требуется какая-либо обработка данных, но требуется запустить сразу несколько заданий с одинаковыми параметрами, то вы можете опустить параметр data. Например, вычислим апроксимацию числа пи методом Монте-Карло:
```{r }
library(RBOINC.cl)

N = 10000

pi_approx = function()
{
  a = runif(N,0,1)
  b = runif(N,0,1)
  res = sum(a*a+b*b < 1)/N
  return(res)
}

res = test_jobs(pi_approx, n = 10, global_vars = list(N = N))

prob = 0
count = 0
for(val in res){
  prob = prob + val$result
  count = count + 1
}
print(prob/count*4)
```

Обратите внимание, что в этом случае прототип функции обработки меняется: теперь это функция без параметров. Здесь мы воспользовались дополнительным праметром global_vars, для передачи числа точек для генерации. global_vars обязательно должен быть списком в котором имена элементов соответствуют глобальным переменным. В качестве глобальной переменной можно передавать любой объект, который можно сохранить. Например, умножим нечётные элементы на 3, а чётные разделим на 2:
```{r }
library(RBOINC.cl)

N = 10000

d = function(val)
{
  return(val/2)
}

m = function(val)
{
  return(val*3)
}

fun = function(val)
{
  if(mod(val,2) == 0){
    res = d(val)
  } else {
    res = m(val)
  }
  return(res)
}

data = 1:10

# Здесь мы передаём функции как глобальные переменные:
res = test_jobs(fun, data, 3, global_vars = list(d = d, m = m), packages = "numbers")

for(val in res){
  print(val$result)
}
```

Здесь мы воспользовались дополнительным параметром packages для передачи пакета. В общем случае можно передать несколько пакетов, в виде вектора из строк, т.е:
``` {r eval=FALSE}
res = test_jobs(fun, data, 3, global_vars = list(d = d, m = m), packages = c("package1", "package2"))
```

### Параметр callback_function 
Зачастую необходимо как-то проверить данные, сохранить или выполнить постобработку. В этом случае можно передать функцию обратного вызова через callback_function. Эта функция должна принимать 1 параметр, равный элементу результата. То, что возвращает эта функция будет считаться результатом задания и помещаться в массив результата. Например, выведем все значения [второго примера](#test_jobs_example_2) через print, а в качестве результата вернём NULL:
```{r }
library(RBOINC.cl)

fun = function(val)
{
  return(val*5)
}

callback = function(val)
{
  print(val)
  return(NULL)
}

data = 1:9

res = test_jobs(fun, data, 2, callback_function = callback)

for(val in res){
  print(val$result)
}
```

### Параметры init_func и files

## Функция create_connection

## Функция close_connection

## Функция create_jobs

## Функция update_jobs_status

## Функция cancel_jobs
